from core import CommonFunctions
import requests
from urllib.parse import urlparse
from urllib.parse import urlunparse
from urllib.parse import parse_qsl
from urllib.parse import urlencode
import multiprocessing
from bs4 import BeautifulSoup
import re
import Config
import time
import copy

def sqli_scan_urls(uEndPoints, findings):

    sqli_completed_urls = []
    urls_uniq = []
    for e in uEndPoints:
        parsed_url = urlparse(e.url)
        params = parse_qsl(parsed_url.query)

        params_count = len(params)
        new_params_clean = []
        for i in range(0, params_count):
            new_params_clean.append((params[i][0], ""))
        new_url_clean = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, parsed_url.params,
                                    urlencode(new_params_clean), None))

        if e.url.find("?") != -1 and new_url_clean not in sqli_completed_urls:
            sqli_completed_urls.append(new_url_clean)
            urls_uniq.append(e.url)
    # Basic Error based detection
    pool = multiprocessing.Pool(processes=Config.number_of_threads)
    ret = pool.map(sqli_scan_url_error, urls_uniq)
    pool.close()
    pool.join()
    for r in ret:
        if len(r["sqlinjection"]) != 0:
            findings["sqlinjection"].extend(r["sqlinjection"])

    # Blind based detection
    pool = multiprocessing.Pool(processes=Config.number_of_threads)
    ret = pool.map(sqli_scan_url_blind_or, urls_uniq)
    pool.close()
    pool.join()
    for r in ret:
        if len(r["sqlinjection"]) != 0:
            findings["sqlinjection"].extend(r["sqlinjection"])
    # Time based detection
    pool = multiprocessing.Pool(processes=Config.number_of_threads)
    ret = pool.map(sqli_scan_url_blind_time_and, urls_uniq)
    pool.close()
    pool.join()
    for r in ret:
        if len(r["sqlinjection"]) != 0:
            findings["sqlinjection"].extend(r["sqlinjection"])

    return

def get_request_time(url):
    try:
        start_time = time.time()
        response = requests.get(url, headers=Config.headers, allow_redirects=True,
                                proxies={"http": Config.http_proxy, "https": Config.https_proxy}, verify=False,
                                timeout=Config.timeout)
        end_time = time.time()
        t = end_time - start_time
        return t
    except:
        return

def sqli_scan_url_blind_time_and(url):
    findings = {"sqlinjection":[]}
    parsed_url = urlparse(url)
    params = parse_qsl(parsed_url.query)

    base_text_clean = get_request_time(url)


    params_count = len(params)
    new_params_clean = []
    for i in range(0, params_count):
        new_params_clean.append((params[i][0], ""))
    new_url_clean = urlunparse(
        (parsed_url.scheme, parsed_url.netloc, parsed_url.path, None, urlencode(new_params_clean), None))
    # loop through all parameters, injecting at index i
    for payload in Config.payloads_time:
        for i in range(0, params_count):
            new_params = []
            parameter = ""
            for j in range(0, params_count):
                if i == j:
                    new_params.append((params[j][0], params[j][1] + payload))
                    parameter = params[j][0]
                else:
                    new_params.append((params[j][0], params[j][1]))
            queryString = urlencode(new_params)
            new_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, None, queryString, None))
            total_time = get_request_time(new_url)
            if total_time != None and total_time > 5:
                error_msgs = [{"dbms": "Unknown", "error_msgs": "Blind SQL Injection - Time Based"}]
                findings["sqlinjection"].append(
                    {"url": url, "url1": url, "form": "no", "payload": queryString, "method": "get",
                     "parameter": parameter + " =" + payload,
                     "sql_error_msgs": error_msgs})
    return findings


def sqli_scan_url_blind_or(url):
    findings = {"sqlinjection":[]}

    parsed_url = urlparse(url)
    params = parse_qsl(parsed_url.query)

    base_text_clean = sqli_url_text(url)

    params_count = len(params)
    new_params_clean = []
    for i in range(0, params_count):
        new_params_clean.append((params[i][0], ""))
    new_url_clean = urlunparse(
        (parsed_url.scheme, parsed_url.netloc, parsed_url.path, None, urlencode(new_params_clean), None))
    # loop through all parameters, injecting at index i
    for i in range(0, params_count):
        new_params = []
        parameter = ""
        for j in range(0, params_count):
            if i == j:
                new_params.append((params[j][0], params[j][1] +"'\"`"))
                parameter = params[j][0]
            else:
                new_params.append((params[j][0], params[j][1]))
        queryString = urlencode(new_params)
        new_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, None, queryString, None))
        base_text_injection = sqli_url_text(new_url)
        base_text_injection = re.sub("'\"","",base_text_injection)
        if base_text_clean == base_text_injection:
            continue
        else:
            k = 0
            for payload in Config.payload_blind_sqli_and_1:
                new_params = []
                parameter = ""
                for j in range(0, params_count):
                    if i == j:
                        new_params.append((params[j][0], params[j][1] + payload))
                        parameter = params[j][0]
                    else:
                        new_params.append((params[j][0], params[j][1]))
                queryString = urlencode(new_params)
                new_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, None, queryString, None))
                text_injected = sqli_url_text(new_url)
                payload = payload.replace("(","\(")
                payload = payload.replace(")","\)")
                text_injected = re.sub(payload,"",text_injected)

                if text_injected == base_text_clean:
                    new_params = []
                    parameter = ""
                    for j in range(0, params_count):
                        if i == j:
                            new_params.append((params[j][0], params[j][1] + Config.payload_blind_sqli_and_2[k]))
                            parameter = params[j][0]
                        else:
                            new_params.append((params[j][0], params[j][1]))
                    queryString1 = urlencode(new_params)
                    new_url = urlunparse(
                        (parsed_url.scheme, parsed_url.netloc, parsed_url.path, None, queryString1, None))
                    text_injected1 = sqli_url_text(new_url)
                    payload1 = Config.payload_blind_sqli_and_2[k]
                    payload1 = payload1.replace(")", "\)")
                    payload1 = payload1.replace("(", "\(")

                    text_injected1 = re.sub(payload1, "", text_injected1)
                    if text_injected1!= base_text_clean:
                        error_msgs = [{"dbms": "Unknown", "error_msgs": "Blind SQL Injection"}]
                        payload = payload.replace("\(", "(")
                        payload = payload.replace("\)", ")")
                        findings["sqlinjection"].append(
                            {"url": url, "url1": url, "form": "no", "payload": queryString, "method": "get",
                             "parameter": parameter + " =" + payload,
                             "sql_error_msgs": error_msgs})

                k = k + 1
    return findings

def sqli_scan_url_error(url):
    findings = {"sqlinjection":[]}
    parsed_url = urlparse(url)
    params = parse_qsl(parsed_url.query)

    params_count = len(params)
    new_params_clean = []
    for i in range(0, params_count):
        new_params_clean.append((params[i][0], ""))
    new_url_clean = urlunparse(
        (parsed_url.scheme, parsed_url.netloc, parsed_url.path, None, urlencode(new_params_clean), None))
    # loop through all parameters, injecting at index i
    for i in range(0, params_count):
        new_params = []
        parameter = ""
        for j in range(0, params_count):
            if i == j:
                new_params.append((params[j][0], params[j][1] +"'\"`"))
                parameter = params[j][0]
            else:
                new_params.append((params[j][0], params[j][1]))
        queryString = urlencode(new_params)
        new_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, None, queryString, None))
        error_msgs = check_sqli_error(new_url)
        if error_msgs != None and len(error_msgs) > 0:
            should_verify = False
            verification_result = False
            if error_msgs[0]["error_msgs"] == "500 - Internal Server Error -> Possible SQL Injection" or error_msgs[0]["error_msgs"] == "Content-Length: 0 -> Possible SQL Injection":
                should_verify = True
                verification_result, payload = verify_sqli_url(url,i)

            if should_verify and verification_result:
                error_msgs[0]["error_msgs"] = "Verified - " + error_msgs[0]["error_msgs"]
                findings["sqlinjection"].append(
                    {"url": url, "url1": url, "form":"no", "payload": queryString, "method": "get", "parameter": parameter + " ="+payload,
                     "sql_error_msgs": error_msgs})

            if should_verify == False:
                findings["sqlinjection"].append(
                {"url": url, "url1": url, "form": "no", "payload": queryString, "method": "get", "parameter": parameter,
                 "sql_error_msgs": error_msgs})
        # if lensqli != None:
    return findings

def verify_sqli_url(url, index):
    parsed_url = urlparse(url)
    params = parse_qsl(parsed_url.query)

    params_count = len(params)
    new_params_clean = []
    for i in range(0, params_count):
        new_params_clean.append((params[i][0], ""))
    new_url_clean = urlunparse(
        (parsed_url.scheme, parsed_url.netloc, parsed_url.path, None, urlencode(new_params_clean), None))
    # loop through all parameters, injecting at index i
    for payload in Config.auth_bypass_payloads:
        new_params = []
        parameter = ""
        for j in range(0, params_count):
            if index == j:
                new_params.append((params[j][0], params[j][1] + payload))
                parameter = params[j][0]
            else:
                new_params.append((params[j][0], params[j][1]))
        queryString = urlencode(new_params)
        new_url = urlunparse((parsed_url.scheme, parsed_url.netloc, parsed_url.path, None, queryString, None))
        error_msgs = check_sqli_error(new_url)
        if error_msgs != None and len(error_msgs) > 0:
            continue
        else:
            return True, payload
    return False, None


def check_sqli_error(url):
    headers = {'User-Agent': Config.user_agent}
    try:
        r = requests.get(url, headers=headers, allow_redirects=True, proxies={"http": Config.http_proxy, "https": Config.https_proxy},
                     verify=False,stream=True, timeout=Config.timeout)
        if  'Content-Length' in r.headers and int(r.headers.get('Content-Length')) > Config.max_response_size:
            return
    except requests.exceptions.RequestException as e:
        return
    if r.status_code == 500:
        error_msgs = []
        error_msgs.append({"dbms": "Unknown", "error_msgs":"500 - Internal Server Error -> Possible SQL Injection"})
        return error_msgs

    if r.status_code != 200:
        return
    try:
        response_text = r.content.decode('utf-8', errors='ignore')
    except:
        return

    if len(response_text) == 0:
        error_msgs = []
        error_msgs.append({"dbms": "Unknown", "error_msgs":"Content-Length: 0 -> Possible SQL Injection"})
        return error_msgs
    error_msgs = []
    for dbms, errors in Config.sql_errors.items():
        for error in errors:
            s = re.search(error, response_text, re.MULTILINE)
            if s:
                error_msgs.append({"dbms": dbms, "error_msgs": s.group()})
    return error_msgs


def sqli_url_text(url):
    retValue = ""
    try:
        r = requests.get(url, headers=Config.headers, allow_redirects=True, proxies={"http": Config.http_proxy, "https": Config.https_proxy},
                     verify=False, stream=True, timeout=Config.timeout)
        if 'Content-Length' in r.headers and  int(r.headers.get('Content-Length')) > Config.max_response_size:
            return retValue
    except requests.exceptions.RequestException as e:
        return retValue

    try:
        response_text = r.content.decode('utf-8', errors='ignore')
        text = BeautifulSoup(response_text,"html.parser").text
        retValue = re.sub("\s+", " ", text).strip()
    except:
        return retValue

    if len(response_text) == 0:
        return retValue

    return retValue




def check_sqli_error_form(req, loginForm, params):

    headers = {'User-Agent': Config.user_agent}

    try:
        if loginForm.method.lower()=='get':
            r = req.get(loginForm.action, headers=headers, params=params, allow_redirects=False,
                          proxies={"http": Config.http_proxy, "https": Config.https_proxy}, verify=False, timeout=Config.timeout)
        else:
            r = req.post(loginForm.action, headers=headers, data=params, allow_redirects=False,
                          proxies={"http": Config.http_proxy, "https": Config.https_proxy}, verify=False, timeout=Config.timeout)
    except requests.exceptions.RequestException as e:
        return

    if r.status_code == 500:
        error_msgs = []
        error_msgs.append({"dbms": "Unknown", "error_msgs":"500 - Internal Server Error -> Possible SQL Injection"})
        return error_msgs


    if r.status_code != 200:
        return

    try:
        response_text = r.content.decode('utf-8', errors='ignore')
    except:
        return


    if len(response_text) == 0:
        error_msgs = []
        error_msgs.append({"dbms": "Unknown", "error_msgs":"Content-Length: 0 -> Possible SQL Injection"})
        return error_msgs

    error_msgs = []
    for dbms, errors in Config.sql_errors.items():
        for error in errors:
            s = re.search(error, response_text, re.MULTILINE)
            if s:
                error_msgs.append({"dbms": dbms, "error_msgs": s.group()})

    return error_msgs

def form_get_time(req, loginForm, params):

    headers = {'User-Agent': Config.user_agent}
    start_time = time.time()
    try:
        if loginForm.method.lower()=='get':
            r = req.get(loginForm.action, headers=headers, params=params, allow_redirects=False,
                          proxies={"http": Config.http_proxy, "https": Config.https_proxy}, verify=False, timeout=Config.timeout)
        else:
            r = req.post(loginForm.action, headers=headers, data=params, allow_redirects=False,
                          proxies={"http": Config.http_proxy, "https": Config.https_proxy}, verify=False, timeout=Config.timeout)
    except requests.exceptions.RequestException as e:
        pass
    end_time = time.time()

    return end_time - start_time


def submit_form_and_get_text(req, loginForm, params):
    retValue = ""
    headers = {'User-Agent': Config.user_agent}

    try:
        if loginForm.method.lower()=='get':
            r = req.get(loginForm.action, headers=headers, params=params, allow_redirects=False, stream=True,
                          proxies={"http": Config.http_proxy, "https": Config.https_proxy}, verify=False, timeout=Config.timeout)
        else:
            r = req.post(loginForm.action, headers=headers, data=params, allow_redirects=False,stream=True,
                          proxies={"http": Config.http_proxy, "https": Config.https_proxy}, verify=False, timeout=Config.timeout)
        if 'Content-Length' in r.headers and int(r.headers.get('Content-Length')) > Config.max_response_size:
            return retValue
    except requests.exceptions.RequestException as e:
        return retValue

    try:
        response_text = r.content.decode('utf-8', errors='ignore')
        soup = BeautifulSoup(response_text,"html.parser")
        text = soup.text
        retValue = re.sub("\s+", " ", text).strip()
    except:
        return retValue

    return retValue



def verify_sqli_form(req, fEndpoint, index):
    if "wp-login" in fEndpoint.action:
        return False
    # test sqli in all parameters
    if fEndpoint == None:
        return False
    for payload in Config.auth_bypass_payloads:
        fEndpoint = CommonFunctions.refetch_form(req, fEndpoint)
        if fEndpoint == None:
            break
        params = fEndpoint.params["dynamic"]
        key = list(params.keys())[index]
        params[key] = params[key] + payload
        params.update(fEndpoint.params['static'])
        error_msgs = check_sqli_error_form(req, fEndpoint,params)
        if error_msgs != None and len(error_msgs) > 0:
            continue
        else:
            return True, payload
    return False, None




def sqli_scan_forms_error(fEndpoint_1):
    findings = {"sqlinjection":[]}

    req = requests.Session()
    if "wp-login" in fEndpoint_1.action:
        return findings
    # test sqli in all parameters

    params_count = len(fEndpoint_1.params["dynamic"])
    for i in range(0,params_count):
        fEndpoint = copy.deepcopy(fEndpoint_1)
        fEndpoint = CommonFunctions.refetch_form(req, fEndpoint)
        if fEndpoint == None:
            break
        params = fEndpoint.params["dynamic"]
        key = list(params.keys())[i]
        params[key] = params[key] + "'\"`"
        params.update(fEndpoint.params['static'])
        error_msgs = check_sqli_error_form(req, fEndpoint,params)
        if error_msgs != None and len(error_msgs) > 0:

            should_verify = False
            verification_result = False
            if error_msgs[0]["error_msgs"] == "500 - Internal Server Error -> Possible SQL Injection":
                should_verify = True
                verification_result, payload = verify_sqli_form(req, fEndpoint, i)
            if error_msgs[0]["error_msgs"] == "Content-Length: 0 -> Possible SQL Injection":
                should_verify = True
                verification_result, payload = verify_sqli_form(req, fEndpoint, i)

            if should_verify and verification_result:
                error_msgs[0]["error_msgs"] = "Verified - " + error_msgs[0]["error_msgs"]
                findings["sqlinjection"].append(
                    {"url": fEndpoint.referer, "url1": fEndpoint.action, "form": "yes",
                     "method": fEndpoint.method.lower(), "parameter": key + "="+payload, "payload": urlencode(params),
                     "sql_error_msgs": error_msgs})

            if should_verify == False:
                findings["sqlinjection"].append(
                    {"url": fEndpoint.referer, "url1": fEndpoint.action, "form": "yes",
                     "method": fEndpoint.method.lower(), "parameter": key, "payload": urlencode(params),
                     "sql_error_msgs": error_msgs})
    return findings

def sqli_scan_forms_or(fEndpoint):
    findings = {"sqlinjection":[]}
    req = requests.Session()
    if "wp-login" in fEndpoint.action:
        return findings


    params_count = len(fEndpoint.params["dynamic"])
    index = 0
    for payload in Config.payload_blind_sqli_or_1:
        for i in range(0,params_count):
            fEndpoint1, base_text = CommonFunctions.refetch_form_and_text(req, fEndpoint)
            if fEndpoint1 == None:
                break
            params = fEndpoint1.params["dynamic"]
            key = list(params.keys())[i]
            params[key] = params[key] + payload
            params.update(fEndpoint1.params['static'])

            sqli_text1 = submit_form_and_get_text(req, fEndpoint1,params)
            if base_text!= sqli_text1:
                fEndpoint2, base_text = CommonFunctions.refetch_form_and_text(req, fEndpoint)
                if fEndpoint2 == None:
                    break
                params = fEndpoint2.params["dynamic"]
                key = list(params.keys())[i]
                params[key] = params[key] + Config.payload_blind_sqli_or_2[index]
                params.update(fEndpoint2.params['static'])

                sqli_text2 = submit_form_and_get_text(req, fEndpoint2, params)
                if sqli_text2!=sqli_text1 and sqli_text2==base_text:
                    findings["sqlinjection"].append(
                        {"url": fEndpoint.referer, "url1": fEndpoint.action, "form": "yes",
                         "method": fEndpoint.method.lower(), "parameter": key, "payload": urlencode(params),
                         "sql_error_msgs": [{"dbms": "Unknown", "error_msgs":"Blind SQL Injection"}]})
        index = index+1
    return findings
def sqli_scan_forms_time(fEndpoint):
    findings = {"sqlinjection":[]}
    req = requests.Session()
    if "wp-login" in fEndpoint.action:
        return findings
    # test sqli in all parameters

    params_count = len(fEndpoint.params["dynamic"])
    index = 0

    params1 = fEndpoint.params["dynamic"]
    params1.update(fEndpoint.params['static'])
    base_request_time = form_get_time(req,fEndpoint,params1)

    for payload in Config.payloads_time:
        for i in range(0,params_count):
            fEndpoint1 = copy.deepcopy(fEndpoint)
            if fEndpoint1 == None:
                break
            params = fEndpoint1.params["dynamic"]
            key = list(params.keys())[i]
            if params[key] =="": # no need to test "and based time" but later on make
                pass
            params[key] = params[key] + payload
            params.update(fEndpoint1.params['static'])

            total_request_time = form_get_time(req, fEndpoint1,params)
            if base_request_time != None and total_request_time!=None and base_request_time < 5 and total_request_time  > 5 :
                findings["sqlinjection"].append(
                    {"url": fEndpoint.referer, "url1": fEndpoint.action, "form": "yes",
                     "method": fEndpoint.method.lower(), "parameter": key, "payload": urlencode(params),
                     "sql_error_msgs": [{"dbms": "Unknown", "error_msgs":"Time Based Blind SQL Injection"}]})
        index = index+1
    return findings

def sqli_scan_forms(fEndpoints, findings):
    pool = multiprocessing.Pool(processes=Config.number_of_threads)
    ret = pool.map(sqli_scan_forms_error, fEndpoints)
    pool.close()
    pool.join()
    for r in ret:
        if len(r["sqlinjection"]) != 0:
            findings["sqlinjection"].extend(r["sqlinjection"])

    pool = multiprocessing.Pool(processes=Config.number_of_threads)
    ret = pool.map(sqli_scan_forms_or, fEndpoints)
    pool.close()
    pool.join()
    for r in ret:
        if len(r["sqlinjection"]) != 0:
            findings["sqlinjection"].extend(r["sqlinjection"])


    pool = multiprocessing.Pool(processes=Config.number_of_threads)
    ret = pool.map(sqli_scan_forms_time, fEndpoints)
    pool.close()
    pool.join()
    for r in ret:
        if len(r["sqlinjection"]) != 0:
            findings["sqlinjection"].extend(r["sqlinjection"])


